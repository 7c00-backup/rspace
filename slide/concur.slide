# This is a file.

Concurrency
is not
Parallelism
(it's better)

Rob Pike
r@golang.org
Waza
Jan 11, 2012

* The modern world is parallel

Multicore.

Networks.

Clouds of CPUs.

Loads of users.

Our technology should help.
That's where concurrency comes in.

* Go supports concurrency

Go provides:
- concurrent execution (goroutines)
- synchronization and messaging (channels)
- multi-way concurrent control (select)

* Concurrency is cool! Yay parallelism!!

NO! A fallacy.

When Go was announced, many were confused by the distinction.

"I ran the prime sieve with 4 processors and it got slower!"

* Concurrency

Programming as the composition of independently executing processes.

(Processes in the general sense, not Linux processes. Famously hard to define.)

* Parallelism

Programming as the simultaneous execution of (possibly related) computations.

* Concurrency vs. parallelism

Programming as the composition of independently executing processes.

vs.

Programming as the simultaneous execution of (possibly related) computations.

Not obviously the same. One is about structure, one is about execution.

Concurrency provides a way to structure a solution to solve a problem that may (but not necessarily) be parallelizable.

* Concurrency

Concurrency is a way to structure a program by breaking it into pieces that can be executed independently.

Go's model (as in many languages) is based on CSP:

Hoare: Communicating Sequential Processes

* An analogy

Concurrent: Mouse, keyboard, display, and disk drivers.

Parallel: Vector dot product.

* Gophers

This is too abstract. Let's get concrete.

* Our problem

image concur/gophersimple1.jpg

Only one gopher will take too long.

* More gophers!

image concur/gophersimple3.jpg

More gophers are not enough; they need more carts.

* More gophers and more carts

image concur/gophersimple2.jpg

This will go faster, but there will be bottlenecks at the pile and incinerator.

* Double everything

image concur/gophersimple4.jpg

This will consume books twice as fast.

* Concurrent composition

image concur/gophersimple4.jpg

The concurrent composition of two gopher procedures.

* Concurrent composition.

Our solution is not automatically parallel:
What if only one gopher is moving at a time?
Then it's concurrent, but not parallel.

But the concurrent composition suggests other models.

* Another design

image concur/gophercomplex1.jpg

Four gophers in action.

If we arrange everything right (implausible but not impossible), that's four times faster.

* Concurrent procedures

Four distinct gopher procedures:
- load
- carry
- burn
- return empty

A different concurrent design, a different way to parallelize.

* More parallelization!

We can now parallelize on the other axis; the concurrent design makes it easy. Eight gophers on the move.
image concur/gophercomplex2.jpg

* Another design

Here's another way to structure the problem as the concurrent composition of gopher procedures.
Two gopher procedures, plus a staging pile.

image concur/gophercomplex3.jpg

* Parallelize the usual way

image concur/gophercomplex4.jpg

* Or a different way

Bring the staging pile to the complex model

image concur/gophercomplex5.jpg

* Full on optimization

Use all our techniques. Sixteen gophers hard at work!

image concur/gophercomplex6.jpg

* Lesson

There are many ways to break the processing down.

That's concurrent design.

Once we have the breakdown, parallelization might fall out.

* Back to Computing

In our book transport problem, substitute:
- book pile for web content
- gopher for CPU
- cart for marshaling, rendering
- incinerator for proxy, browser, or other consumer

It's a web service, and we have concurrent design.

* A little background about Go

Not the place for a tutorial, just quick highlights.

* Goroutines

A goroutine is a function running independently  in the same address space.

code concur/snippets /starts.running/ /return/

* Channels

Channels are typed values that allow goroutines to synchronize and exchange information.

code concur/snippets /make.*chan/ /completedAt/

* Select

The select statement is like a switch, but the decision is based on ability to communicate rather than just equal values.

code concur/snippets /select/ /}/

* Go really supports concurrency

It's routine to have thousands of goroutines active in a program.

Stacks start small, but grow and shrink as required.

Goroutines aren't free, but they're very cheap.

* Goroutines are not threads 

(They're much cheaper.)

Goroutines are multiplexed onto threads as required.

When a goroutine blocks, that thread blocks but other goroutines do not.

* Closures are part of the story

Closures are just local functions.
code concur/snippets /Compose/ /sin,/

* Some examples

* Launching daemons

Use a closure to wrap a background operation.

The for range operation runs until channel is drained.
code concur/snippets /copy.input/ /^}/

* A simple load balancer (1)

A unit of work:

code concur/load1 /type/ /^}/

* A simple load balancer (2)

A worker task:

code concur/load1 /worker/ /^}/

* A simple load balancer (3)

The runner:

code concur/load1 /Run/ /^}/

* Concurrency enables parallelism

The load balancer is implicitly parallel and scalable.

The tools of concurrency make it almost trivial to build a safe, working, scalable, parallel design.

* Concurrency simplifies synchronization

No explicit synchronization needed.

The structure of the program is implicitly synchronized.

* That was too easy

Let's do a more realistic load balancer.

* Load balancer

image concur/gopherchart.jpg

* Request definition

The requester sends Requests to the balancer.

code concur/load2 /^type.Request/ /^}/

* Requester function

An artificial but illustrative simulation of a requester.

code concur/load2 /^func.requester/ /^}/

* Worker definition

A channel of requests, plus some load tracking data.

code concur/load2 /type.Worker/ /^}/

* Worker

Balancer sends request to most lightly loaded worker.

code concur/load2 /^func.*work.*done/ /^}/

The channel of requests (w.requests) delivers requests to each worker.  The balancer tracks the number of pending requests as a measure of load.
Each response goes directly to its requester.

* Balancer definition

The load balancer needs a pool of workers and a single channel to which requesters can send work.

code concur/load2 /type.Pool/ /^}/

* Balancer function

Easy!

code concur/load2 /func.*balance/ /^}/

Just need to implement dispatch and completed.

* A heap of channels

Make Pool an implementation of the Heap interface by providing a few methods such as:

code concur/load2 /func.*Less/ /^}/

Now we balance by making the Pool a heap tracked by load.

* Dispatch

All the pieces are in place.

code concur/load2 /Send.Request/ /^}/

* Completed

code concur/load2 /Job.is.complete/ /^}/

* Lessons

XXXX

* One more example

This one is subtler but XXX


* Database multi-way request

Query servers in replicated database, return first response.
code concur/snippets /Query/ /^}/



* Conclusion


Concurrency is powerful.

Concurrency is not parallelism.

Concurrency enables parallelism.

Concurrency makes paralellism (and scaling and everything else) easy.

* For more information

Go: http://golang.org
