Simplicity is Complicated

GoCon
30 Nov 2014

Rob Pike
Google
@rob_pike
[[http://golang.org/s/plusrob][+RobPikeTheHuman]]
http://golang.org/

* こんにちは  Gophers!

.image gocon/gophers.jpg 512 _

* Goの成功

なにが今日のGoの成功を導いたのか？

多くの理由が挙げられています。

- コンパイル速度の速さ
- 実行速度の速さ
- デプロイの容易さ
- ツール
- ライブラリ

これらは言語の特徴ではありません。
あまり挙げられることはないですが、interfaceや並行性といった真の意味での言語の特徴も成功の理由にされています。

これらはすべて重要ですが、本当の答えではありません。

* Simplicity（単純さ）

私の答えは Simplicity（単純さ） です。

Goは単純です。少なくとも既存の普及している言語に比べれば単純です。

単純さには多くの側面があります。

単純さは理解しにくいものです。

* 収束

今年のはじめに [[https://langnext2014.eventday.com/][Lang.Next]] カンファレンスに [[http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/From-Parallel-to-Concurrent?utm_content=bufferf1e11&utm_medium=social&utm_source=twitter.com&utm_campaign=buffer][出席しました]]。

話題はJava、JavaScript (ECMAScript)、Typescript、C#、C++、Hack (PHP)などの新しいバージョンについてでした。

これらの言語はお互い積極的に機能を借りてきています。

これらの言語は一つの大きな言語に収束しようとしています。

* 言語相対性

[[http://ja.wikipedia.org/wiki/%E3%82%B5%E3%83%94%E3%82%A2%EF%BC%9D%E3%82%A6%E3%82%A9%E3%83%BC%E3%83%95%E3%81%AE%E4%BB%AE%E8%AA%AC][サピア＝ウォーフの仮説]] : 言語が思想に影響するという説

自然言語に関する論争。

コンピュータ言語においても同様のことが起きています。例えば次に挙げるプログラミング手法を考えてみてください。

- 論理プログラミング
- 手続き型プログラミング
- 関数プログラミング
- オブジェクト指向プログラミング
- 並行プログラミング

数学における分野に似ています。

* 収束と相対性

もし言語がすべて収束すれば、プログラマの考え方はみな同じものになるでしょう。

しかし考え方が異なるということは良いことです。

異なる問題には異なる言語が必要です。

たった一つの道具ではなく、ひとまとまりの道具から、それぞれのタスクを解決するのに最適なものを選びたいですよね。

* 収束と言語機能

Lang.Nextでのプレゼンテーションは言語の新しいバージョン（Java 8、ECMAScript 6、C#、C++14）についてと言語機能についてでした。

これらの言語は機能を追加することで発展し競争力を高めてきました。

これらの言語はお互い似た機能を持つ言語になる間にその複雑さを成長させてきました。

お互いの差異をつけることなく膨張してきました。

* Goの特徴

Goは違いました。

Goは他の言語と同じようになろうとはしませんでした。

Goは言語機能で競い合うことをしませんでした。

Go 1の時点で、言語機能は固定されました。

Goを始めたばかり人は彼らが知っている言語の機能を追加するよう求めます。
しかしこれらの機能はGoには入りません—そして言語機能は固定されました。

Goに機能を追加することがGoの改善には繋がりません。Goを肥大させるだけです。
Goに機能を追加して他の言語との差異を少なくさせることで、Goがつまらない言語になってしまうのです。

* でも機能は必要です！

もちろん、 _ある程度_ 言語機能は必要です。

でもどの機能が必要なのでしょうか？正しい機能です！

合意によって設計しましょう。

* 可読性

言語の機能が多すぎると、どの機能を使うべきかに時間を取られてしまいます。
その後実装し、改善し、おそらく考えなおして、再び実装します。

しばらくして「なぜこのコードはこのように動くのだろう」と自問することになります。

_コードが単純に複雑な言語を使っているという理由で理解しづらくなっています。_

たった1つのやり方、あるいは少なくともあっても数通りのやり方、それも単純な方法が望ましいです。

機能は複雑さを増します。私達は単純にしたいのです。

機能は可読性を損ないます。私達は可読性を上げたいのです。

可読性は最重要事項です。

* 可読性は信頼性

可読性のあるコードは信頼できるコードです。

理解しやすく

取り組みやすく

壊れてしまっても、簡単に修正できます。

言語が複雑だと、コードを読んだりコードに取り組むのに多くのことを理解しなければなりません。
デバッグや修正のためにより多くのことを理解しなければなりません。

重要なトレードオフ: 書くのが楽しいか、保守が楽か

* 表現力

「表現力」の補助のために機能が提案されることがよくあります。

簡潔であることは表現力を高めることにもなりますが、可読性が高いとは限りません。
（APLの例を考えてみましょう:  ⊃ 1 ω ∨ . ∧ 3 4 = +/ +⌿ 1 0 ‾1 ∘.θ 1 - ‾1 Φ″ ⊂ ω）

単純な考えを強力すぎるプリミティブで実装すると実行コストが上がることにもなりかねません。
パフォーマンスも予測しづらくなります。

一方で、冗長性も本来の意図を曖昧にしてしまい、可読性を下げてしまいます。

馴染みのある考え方に基づいて実装しましょう。しかしその考え方だけにとらわれないようにしましょう。

表現力を残しつつも簡潔に表現しましょう。

* 正しい言語機能

機能のための機能ではありません。

「隙間を埋める」機能が必要です。たとえば解空間を覆う基底ベクトルのようなものです。

予想したとおりに作用する直交する機能が必要です。

単純に動作する単純な機能が必要です。

単純さは直交性と予測可能性に依るものです。

言語の目的を常に肝に命じておきましょう。

* Goの目的

スケーラブルなクラウドソフトウェアのために設計されたきれいな手続き型言語です。

組み立て可能な個別要素からなります。

- 具象データ型
- 関数とメソッド
- interface
- パッケージ
- 並行性

さらに: 良いツールと速いビルド

これらの要素それぞれが実際に単純であると感じます。

* 単純であることは表現力の豊かさにつながる

.image gocon/gopherslide2smblue.jpg 512 _

* すべての機能が必要ではない

明瞭さのない複雑さを追加することなります。

.image gocon/gopherslide2sm.jpg 512 _

* 単純さ

Goは実際には複雑だけれど、単純だと _感じます_ 。

要素はお互いにシームレスに調和し、驚きがあってはいけません。

単純だと多くの設計、実装、改善が必要となります。

単純さは複雑さを隠す秘訣です。

* Goでの単純なこと

- ガベージコレクション
- goroutines
- 定数
- interfaces
- パッケージ

それぞれが単純な見た目の裏にある複雑さを隠してくれています。

* ガベージコレクション

おそらく複雑さを隠す単純さの最たる例です。

うまく実装するのがとても難しいけれど、その価値があります。
難しさとは裏腹に、言語仕様の紹介でちょっと出てくるだけです。
それにもかかわらず、GoではGCに強く依存しているところがあります。

コードが単純に書けるのはGCのおかげです。
設計に「所有権」を含める必要はありません。

Goには `free` がありません。GCだけがあります。
出来る限り単純に書くことができます。（しかしその見た目の裏側は複雑です。）

* 並行性

並行性とは、プログラムを独立して実行している部品のように書ける能力のことです。
Goでは並行性は3つの要素からなります。

- goroutine （実行）
- チャネル （コミュニケーション）
- `select` （調整）

まずgoroutineについて見てみましょう。

* Goroutines

キーワード `go` を使ってgoroutineを起動します。

	go function(args)

キーを余分に3つ押すだけです。('g', 'o', ' ') これより単純にすることは難しいでしょう。

ガベージコレクションのように、プログラマの心配からくる考え事をなくしてくれます。

- スタックサイズがない
- returnや終了ステータスがない
- 管理する機構がない
- "ID" がない

これらは他のシステムでは提供しています。代わりにGoでは最小設計にしています。

その実装は複雑で、スタックの管理はGCに依存しています。

* 定数

Goでは定数はただの数です。たとえ強く型付けがされていてもです。

	var nanosecond = time.Second/1e9

単純な考えですが、実際にそう決めるには1年ほどかかりました。難しかった点は次のとおりです。

- 「無限」精度整数型
- 「無限」精度浮動小数点型（試してみて、有理数で失敗した）
- 昇格規則（ `i` `:=` `2;` `f` `:=` `2.0;`  `g` `:=` `1/2;` `h` `:=` `1/2.0` ）
- シフトのようなコーナーケース

.play gocon/shift.go /Printf/

十分に満たしてはいませんが、定数を数字のように扱えるようになっていて、Goの使いやすさに貢献しています。しかしその裏側は複雑です。

詳しくは[[http://blog.golang.org/constants][このブログポスト]]を見てください。

* Interface

ただのメソッドのまとまりです。データはありません。単純な考えですが、予想以上に複雑です。

	type Reader interface {
		Read([]byte) (int, error)
	}

この型の変数も必要です。（ `var` `reader` `io.Reader` ）
これらの変数は静的型付け言語に動的型付けの要素を追加します。

	var r Reader = os.Stdin // 静的にチェックされる
	var x interface{} = os.Stdin // 静的にチェックされる
	r = x.(Reader) // 動的にチェックされる。明示的に書かなければいけない。 - 設計に依るもの

注意深く設計する必要があります。interface代入は実行時（v-tableではなく）に実装されなければなりません。もし失敗したらどうしましょう？型アサーションと「カンマOK」イディオムに話が繋がります。

もっと複雑なことが忍び込んでいます。型アサーションと型switchは本来の計画ではありませんでした。

* Interface

Goでもっとも特徴的で強力な機能です。

ライブラリ設計において非常に大きな効果がありました。

真のコンポーネントアーキテクチャを可能にしました。最たる例が `io.Reader` と `io.Writer` で、これはUnixのパイプの考え方を一般化したものです。

単純に感じることができ、その裏の複雑さに値するものです。

* パッケージ

プログラムとライブラリを構成するための設計です。

	package big
	...
	import "math/big"

設計には長い時間がかかりました。コンポーネント化、スケーラビリティ、共有、データの隠蔽と隔離などを可能にしました。

プログラムの設計、構文、命名、ビルド、リンク、テストなどに影響を与えました。

パッケージのパス（ `"math/big"` ）とパッケージ名（ `big` ）を別にしました。
`go` `get` 機構を可能にしました。

いまだに実装は難解ですが、自然に使えます。

GCについで、おそらく見た目の単純さに比べた真の複雑さを裏に持った機能です。またそれ故、複雑さを隠す単純さを持っています。

* 「単純な」例

.play gocon/hello.go

* 隠された複雑さ

UnicodeとUTF-8はシームレスに扱われます。

パッケージは簡単にインポートし使うことができます。

`Fprintf` を直接ネットワーク接続に使うことができます。

関数はメソッドに昇格します（ `HandleFunc` ）。

真の並行サーバはブロックしません。

プロダクション環境に耐えます。

すべて非常に単純です。

* まとめ

単純さは複雑なことだけれど、その明瞭さは戦う価値があります。

.image gocon/gopherslide2sm.jpg 512 _

* 結論

単純さは設計が難しい。

単純さを作るのは複雑。

でももし正しく作ることができたら...

単純さは使いやすさとなります。

Goの成功がそれを証明しています。

.image gocon/gopherslide2smblue.jpg 256 _
